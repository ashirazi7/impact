%sample file for Modelica 2015 Conference paper

\documentclass[11pt,a4paper,twocolumn]{article}
\usepackage{graphicx}
% uncomment according to your operating system:
% ------------------------------------------------
%\usepackage[latin1]{inputenc}    %% european characters can be used (Windows, old Linux)
\usepackage[utf8]{inputenc}     %% european characters can be used (Linux)
%\usepackage[applemac]{inputenc} %% european characters can be used (Mac OS)
% ------------------------------------------------
\usepackage[T1]{fontenc}     %% get hyphenation and accented letters right
\usepackage{mathptmx}        %% use fitting times fonts also in formulas
\usepackage{amsmath,amssymb} %% Nice maths
\usepackage[round]{natbib}   %% author-year style referencing
\usepackage{doi}             %% Create cor足rect hy足per足links for DOI num足bers
\usepackage{booktabs}        %% Nice tables
\usepackage{hyperref}
\usepackage{color}
\usepackage[labelfont=bf, labelsep=period, font=small]{caption}  %% Get bold Figure/Table caption
               %% Set separator in figures to '.', set fontsize to small
\usepackage{authblk}         %% Prepare author and affiliation blocks
\usepackage{courier}         %% For proper courier fonts in texttt
\usepackage{listings}        %% For code sections
%\usepackage[bw]{dtsyntax}    %% For Modelica code

% do not change these lines:
\pagestyle{empty}                %% no page numbers!
\usepackage{geometry}            %% please don't change geometry settings!
\geometry{left=20mm, right=20mm, top=25mm, bottom=25mm, noheadfoot}

\hypersetup{
  pdftitle = {Where impact got going},
  pdfauthor = {Michael Tiller and Dietmar Winkler},
  pdfsubject = {11th International Modelica Conference 2015},
  pdfkeywords = {Modelica, package manager, GitHub, dependency management, golang},
  hidelinks,
  pdfpagelayout=SinglePage}

\renewcommand{\normalsize}{\fontsize{10.5pt}{12.3pt}\selectfont}
\renewcommand{\small}{\fontsize{9.5pt}{11.1pt}\selectfont}
\renewcommand{\footnotesize}{\fontsize{8.5pt}{9.9pt}\selectfont}

%% Modelica code configuration
% \lstset{language = Modelica,
%        basicstyle=\fontsize{9pt}{10.5pt}\selectfont,
%        backgroundcolor = \color{white}}

% usefull commands
\newcommand{\myr}{\textsuperscript{\textregistered}}
\newcommand{\ud}{\mathrm{d}}
\newcommand{\matx}[1]{\mathbf{#1}}
\newcommand{\impact}{\texttt{impact}} % impact is going to get used quite a lot :)
\newcommand{\code}[1]{\texttt{#1}} % make quoting code text a bit simpler


% begin the document
\begin{document}
\thispagestyle{empty}

\title{\textbf{Where \impact\ got \emph{go}ing}}
\renewcommand\Authfont{\large}        %% Set author font
\renewcommand\Affilfont{\normalsize}       %% Set affiliation font
\renewcommand\Authsep{\quad}                     %% Set text between authors names
\renewcommand\Authand{\quad}                     %% Set text between authors names
\renewcommand\Authands{\quad}                    %% Set text between authors names
\author[1]{Michal Tiller}
\author[2]{Dietmar Winkler}
\affil[1]{\href{http://xogeny.com}{Xogeny Inc.}, USA, {\small \href{mailto:michael.tiller@xogeny.com}{\nolinkurl{michael.tiller@xogeny.com}}}}
\affil[2]{\href{http://www.hit.no}{Telemark University College}, Norway, {\small\href{mailto:dietmar.winkler@hit.no}{\nolinkurl{dietmar.winkler@hit.no}}}}
% \title{\textbf{Int. Modelica Conf. 2015 Paper Title}}
% \author{{\large
% Author Name$^1$ \quad Author Name$^1$ \quad Author Name$^2$\vspace{2mm}\\
%   {}$^1$Department, University, Country, \textsf{\{name1,name2\}@university.org}\\
%   {}$^2$Company, Contry, \textsf{name3@company}}


\date{} % <--- leave date empty
\maketitle\thispagestyle{empty} %% <-- you need this for the first page
\abstract{

  This paper discussed the \code{impact} package manager.  The primary
  goal of this project is to support the development of a healthy
  eco-system around Modelica.  For many other languages, the existance
  of an easy to use package manager has made it easier for people to
  explore and adopt those languages.  We seek to bring that same kind
  of capability to the Modelica community by incorporating useful
  features from other package managers like \code{bower}, \code{npm},
  \it{etc}.

  This paper is an update on the status of the \code{impact} package
  manager which was discussed previously in \cite{impact1}.  This
  latest version of \code{impact} involves a complete rewrite that
  incorporates a more advanced dependency resolution algorithm.  That
  dependency resolution will be discussed in depth along with many of
  the subtle issues that arose during the development of this latest
  version of impact.  Along with a superior dependency resolution
  scheme, the new version of \code{impact} is much easier to install
  and use.  Futhermore, it includes many useful new features as well.

}

\noindent\emph{Keywords: Modelica, package management, GitHub, dependency resolution, golang}

\section{Introduction}

\subsection{Motivation}

The motivation behind the \code{impact} project is to support two
critical aspects of library development.  The first is to make it very
easy for library developers to {\em publish} their work.  The second
is, at the same time, to make it easy for library consumers to both
find and install published libraries.

We also feel it is important  to reinforce best practices with respect
to model development.   For this reason, we have  made version control
an integral  part of  our solution.   Rather than  putting users  in a
position to have  to figure out how to make  \code{impact} work with a
version control  system, we've build \code{impact}  around the version
control system.   Not only  do users not  have to find  a way  to make
these technologies work together,  \code{impact} actually nudges those
not using  version control  toward solutions that  incorporate version
control.  In this way, we hope to demonstrate to people the advantages
of both \code{impact} and version control and establish both as ``best
practices'' for model development.

By creating a tool that makes it easy to both publish and install
libraries, we feel we are creating a critical piece of the foundation
necessary to establish a {\bf health ecosystem} for model development.

\subsection{History}

Earlier, we mentioned that \code{impact} has been completely
rewritten.  In fact, the very first version of \code{impact} was just
a single Python script for indexing and installing Modelica
code\cite{impact-gist}.  It eventually involved into a multi-file
package that could be installed using the Python package management
tools.

\section{Requirements}

After building the original Python version, we gave some thought to
what worked and what didn't work well.  One issue we ran into almost
immediately was the complexity of installing the Python version of
\code{impact}.  Python is unusual in that it has two package managers,
\code{easy\_install} and \code{pip}.  It comes with
\code{easy\_install}, but \code{pip} is the more capable package
manager.  So in order for someone to install \code{impact}, they first
needed to install Python, then install \code{pip} and then install
\code{impact}.  This was far too complicated.  So we wanted to come up
with a way for people to install \code{impact} {\bf as a simple
  executable} without any runtime or prerequisites.

Another issue we ran into with the Python version was the fact that
there are two different and incompatible versions of Python being used
today.  Trying to support both was an unnecessarily inefficient use of
resources.  For this reason, we felt we needed to move away from
Python altogether.

We also had some difficulties in the Python version with support for
SSL under Windows \cite{python-ssl}.  Because we were doing lots of
``crawling'' (more on this shortly), we needed a platform that
provided {\bf solid HTTP client support}.

Although most users Modelica run their development tools and
simulations under Windows, there are several tools that support OSX
and Linux as well as Windows.  So as to not neglect users of those
tools and to support more cross-platform options, we also wanted to be
able to {\bf compile impact for all three major platforms}.

Furthermore, we wanted to provide a simple executable for all
platforms without having to have actual development machines for each
of these different platforms.  For this reason, {\bf cross
  compilation} between different platforms was an important
consideration was well.

Of course, we also wanted to have {\bf good performance}.  For most
package management related functions, the speed of the internet
connection is probably the biggest limitating factor.  So CPU
performance wasn't that high on the list.  But, as we shall discuss
shortly, the computational complexity of the dependency resolution
algorithm we implemented could lead to some computationally intensive
calculations for complex systems of dependencies.

For these reasons, we ultimately rewrote \code{impact} in Go.  Go is a
relatively new language from Google that stresses simplicity in
language semantics but, at the same time, provides a fairly complete
standard library.  You can think of Go as being quite similar to C
with support for extremely simple object-oriented functionality,
automatic garbage collection and language level support for CSP-based
concurrency.  With Go, we were able to satisfy all the requirements
above.

\section{Version Numbering}

Before we dive into all the details associated with crawling,
indexing, resolving and installing, it is useful to take a moment to
briefly discuss versioning.  Modelica supports the notion of versions
through the use of the `version` and `uses` annotations.  These two
annotations allow libraries to explicitly state what version they are
and what versions of other libraries they use, respectively.

But there is one complication to the way Modelica deals with versions.
In Modelica, a version is simply a string.  This by itself isn't a
problem.  But it becomes a problem, as we will discuss in greater
detail shortly, when you need to understand relationships between
version.  In particular, there are two important things we would like
to determine when dealing with version numbers.  The first is an
unambiguous ordering of versions.  In other words, which, of any two
versions, is the ``latest'' version?  The second is whether a newer
version of a library is ``backwards compatible'' with a previous
version.  These are essential questions when trying to resolve
dependencies and the current string based approach to versions in
Modelica is not semantically rich enough to help us answer either of
these.

This issue is not unique to the Modelica world.  These same questions
have been asked for a very long time and various approaches have been
invented to deal with answering these questions.  One recent and
widely used approach is to employ what is called {\bf semantic
  versioning}\cite{semver}.  Semantic versioning is pretty much what
it sounds like, an approach to defining version numbers where the
version numbers have very explicit meanings associated with them.

A very simple summary of semantic versioning would be that {\bf all}
versions have exactly three numerical components, a major version
number, a minor version number and a patch.  A semantic version must
have all of these numbers and they must be .-separated.  For this
reason, the following versions are not legal semantic version numbers:
\code{1}, \code{1a}, \code{1.0}, \code{1.0-beta5}, \code{4.0.2.4096}.
Each of these number means something.  If you make a non-backward
compatible change, you must increment the major version.  If you make
a backward compatible version, you must increment the minor version.
If you make a change that should be completely compatible with the
previous version, you increment only the patch version.

There are additional provisions in semantic versioning to handle
pre-release versions as well as build annotations.  We will not
discuss those semantics here, but they are incorporated into our
implementation's treatment of version numbers.

Our use of semantic versioning is aligned with our goal of strongly
encouraging best practices.  It is important to point out that the use
of semantic versions is completely legal in Modelica.  In other words,
Modelica allows a wider range of interpretations of version numbers.
By using semantic versions, we narrow these interpretations but we
feel that this narrowing is much better for the developer since it
also provides meaning to the version numbers assigned to a library.

However, because Modelica libraries are free to use nearly any string
as a version number, we need to find a way to ``bridge the gap''
between past usage and the usage we are encouraging moving forward.
Although internally \code{impact} understands {\bf only} semantic
versions, it is still able to work with nearly all existing Modelica
libraries.  This is achieved through a process of ``normalizing''
existing versions.  When \code{impact} comes across versions that are
not legal semantic versions, it attempts to create an equivalent
semantic version representation.  For example, a library with a
version string of \code{1.0} would be represented by the semantic
version \code{1.0.0}.

For this normalization to work, it is important to make sure that the
normalization is performed {\em both} on the version number associated
with a library and on the version numbers of the libraries used.  In
other words, it must be applied consistently to both the
\code{version} and \code{uses} annotations.

\section{Indexing}

\subsection{Sources}

* tags

\subsection{Repository Structure}
\subsubsection{Conventions}
\subsubsection{impact.json}

\subsection{Handling Forks}

* Present basic data structures assuming uniqueness

* forks (URIs, disambiguation)

\subsection{Schema}

* JSON Schema?

\section{Installation}

Talk about what happens during installation.

\subsection{Dependency Resolution}

* Basic algorithm (show some graphs)

* Extracting explicit dependency information from Modelica

* Implicit dependency information from semantic versions

* Backtracking and why it isn't so bad (give some performance numbers here)

\subsection{Directory Structure}

* No version numbers

* In a version control context

\subsection{impact.proj}

* --save option?

* .gitignore and repopulation

* disambiguation

\section{Go Implementation}

* package structure

* 3rd party libraries
  - GitHub API
  - Semver

* GitHub API tokens

* CI

\section{Additional Features}

\subsection{Searching}

* Ordering (matching URI/source then by stars)  

\section{Future Development}

* Bitbucket

* Subversion

* Intranet applications

* Web based search

\section{Conclusion}

* Different files (impact.json, impact.proj, impactrc and their purposes)

%%% Remove the following line once we got real citations in place.
% \nocite{impact}

%--------------------------------------------------------------------------------
% References using bibtex
\small
\bibliographystyle{plainnat}
\bibliography{impact}
\normalsize

\end{document}
